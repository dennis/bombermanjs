<html>
<head>
	<title>Bomberman JS</title>
	<script src="/socket.io/socket.io.js"></script>
	<style>
		#gamearea {
			position: relative;
		}
		canvas {
			position: absolute;
			top: 0px;
			left: 0px;
			background: transparent;
			border: 1px solid black;
		}
	</style>
</head>
<body>
<h1>Bomberman JS</h1>
<div id="gamearea">
<canvas id="background">
Your browser does not support canvas
</canvas>
<canvas id="actors">
</canvas>
</div>
<script>
	// Utilities TODO: Extends Array with these
	function eachPair(array, action) {
		for(var i = 0; i < array.length; i++) {
			action(i, array[i]);
		}
	}
	function each(array, action) {
		eachPair(array, function(idx, element) {
			action(element);
		});
	}
	function NOT_USED_map(array, action) {
		var result = [];

		each(array, function (element) {
			var a = action(element);
			if(a != undefined)
				result.push(a);
		});

		return result;
	}
	function select(array, action) {
		var result = [];

		each(array, function(element) {
			if(action(element))
				result.push(element);
		});

		return result;
	}

	// CanvasManager
	function CanvasManager() {};
	CanvasManager.prototype.init = function(canvasId, mapWidth, mapHeight) {
        this.canvas = document.getElementById(canvasId);

        if(this.canvas.getContext) {
           this.context = this.canvas.getContext('2d');

		   this.canvas.width = mapWidth;
		   this.canvas.height = mapHeight;
        }
        else {
            throw new "No canvas support for element " + canvasId;
        }
	}

    // Background extends Drawable
    function Background(canvasId, mapWidth, mapHeight, tileSet) {
		this.layers = [];
		this.tileSet = tileSet;
		this.dirty = false;

		this.init(canvasId, mapWidth, mapHeight);
	}
    Background.prototype = new CanvasManager();
	Background.prototype.populate = function(layer) {
		this.layers.push(layer);
		this.dirty = true;
	}
    Background.prototype.draw = function() {
		if(!this.dirty) {
			return;
		}

		for(var i = 0; i < this.layers.length; i++) {
			for(var pos = 0; pos < this.layers[i].data.length; pos++) {
				this.tileSet.draw(this.context,pos,this.layers[i].data[pos]-1);
			}
		}

		this.dirty = false;
    }

	// Actors
	function Actors(canvasId, mapWidth, mapHeight, tileSet) {
		this.actors = [];
		this.tileSet = tileSet;

		this.init(canvasId, mapWidth, mapHeight);
	}
	Actors.prototype = new CanvasManager();
	Actors.prototype.populate = function(layer) {
		for(var pos = 0; pos < layer.data.length; pos++) {
			if(layer.data[pos] != 0) {
				var xy = this.tileSet.toXY(pos);
				this.actors.push(new Actor(xy.x, xy.y, layer.data[pos]));
				console.log("  Found actor at " + xy + " using tile-" + layer.data[pos]);
			}
		}
	}
	Actors.prototype.draw = function(tileSet) {
		var that = this;
		each(this.actors, function(actor) {
			actor.draw(that.context, tileSet);
		});
	}

	// Actor
	function Actor(x,y,tileNum) {
		this.x = x;
		this.y = y;
		this.tileNum = tileNum;
	};
	Actor.prototype.draw = function(context, tileSet) {
		tileSet.draw(context, tileSet.fromXY({x: this.x, y: this.y}), this.tileNum);
	}

	// TileSet
	function TileSet(tileSetData, sprite) {
		this.sprite = sprite;

		this.tileWidth = tileSetData.tilewidth;
		this.tileHeight = tileSetData.tileheight;

		this.cols = tileSetData.imagewidth / this.tileWidth;
		this.rows = tileSetData.imageheight / this.tileHeight;
	};

	TileSet.prototype.draw = function(context, pos, tileNum) {
		var tileXY = this.toXY(tileNum);
		var posXY = this.toXY(pos);

		context.drawImage(this.sprite, 
			tileXY.x * this.tileWidth, tileXY.y * this.tileHeight, this.tileWidth, this.tileHeight, 
			posXY.x * this.tileWidth, posXY.y * this.tileHeight, this.tileWidth, this.tileHeight);
	}
	TileSet.prototype.toXY = function(pos) {
		var x = pos % this.cols;
		var y = (pos - x)/ this.cols;
		return {
			x: x,
			y: y,
			toString: function() {
				return "(" + x + "," + y + ")";
			}
		}
	}
	TileSet.prototype.fromXY = function(pos) {
		return pos.y * this.cols + pos.x;
	}
	
	TileSet.prototype.getTileWidth = function() {
		return this.tileWidth;
	}

	TileSet.prototype.getTileHeight = function() {
		return this.tileHeight;
	}

    // Level
    function Level(levelMap, tileSet) {
        var mapWidth = levelMap.width*levelMap.tilewidth;
        var mapHeight = levelMap.height*levelMap.tileheight;

		this.tileSet = tileSet;
        this.background = new Background('background', mapWidth, mapHeight, tileSet);
		this.actors = new Actors('actors', mapWidth, mapHeight, tileSet);

		console.log("Loading map");

		var that = this;

		var visibleLayers = select(levelMap.layers, function(layer) {
			return (layer.type == "tilelayer" && layer.visible && layer.properties);
		});

		eachPair(visibleLayers, function(i, layer) {
			if(layer.properties.type == "background" || layer.properties.type == "blocking") {
				console.log("Loaded layer #" + i + " " + layer.name + " (" + layer.properties.type + ")");
				that.background.populate(layer);
			}
			else if(levelMap.layers[i].properties.type == "spawn") {
				console.log("Loaded layer #" + i + " " + layer.name + " (" + layer.properties.type + ")");
				that.actors.populate(layer);
			}
			else {
				console.error("Ignored layer #" + i + " " + layer.name + " (" + layer.properties.type + ")");
			}
		});
    };

    Level.prototype.draw = function() {
        this.background.draw(this.tileSet);
		this.actors.draw(this.tileSet);
    }

    // main
    var socket = io.connect(document.location.origin);
    var level = null;
	var levelMap = null;

    socket.on('new-level', function (data) {
		levelMap = data;
		console.log("EVENT: new-level");

		// load asset
		var tilesImg = new Image();
		tilesImg.src = levelMap.tilesets[0].image;
		tilesImg.onload = function() {
			console.log("Graphics loaded: ", tilesImg);
			var tileSet = new TileSet(levelMap.tilesets[0], tilesImg);
			level = new Level(levelMap, tileSet);
			console.log("ready");
			animate();
		}
    });

    function animate() {
        requestAnimFrame(animate);
		level.draw();
    }

    window.requestAnimFrame = (function(){
        return window.requestAnimationFrame ||
        window.webkitRequestAnimationFrame ||
        window.mozRequestAnimationFrame ||
        window.oRequestAnimationFrame ||
        window.msRequestAnimationFrame ||
        function(/* function */ callback, /* DOMElement */ element){
            window.setTimeout(callback, 1000 / 60);
        };
    })();
</script>
</body>
</html>
